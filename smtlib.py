from os import path, makedirs, remove
import subprocess
import time
from enum import Enum
from contextlib import contextmanager
import re
from z3 import BitVecVal, BoolVal, Solver


# from oplib import Bv


@contextmanager
def timer():
    start = time.perf_counter_ns()
    yield lambda: time.perf_counter_ns() - start


class SupportedSolvers(Enum):
    CVC: str = 'cvc5'
    YICES: str = 'yices'
    Z3: str = 'z3'


# TODO: Add set-logic command so yices recognizes BVs
def write_smt2(filename: str, solver, ctx=None, logic='QF_AUBV'):
    s = solver
    if not type(s) is Solver:
        s = Solver(ctx=ctx)  # TODO Might need to add ctx back to solver (Solver(ctx=ctx))
        s.add(solver)
    if filename:
        file_dir = path.join(path.dirname(__file__), 'smt2')
        makedirs(file_dir, exist_ok=True)
        filepath = path.join(file_dir, filename)

        with open(filepath, 'w') as f:
            print(f'(set-logic ALL)', file=f)
            print(s.to_smt2(), file=f)
            print('(get-model)', file=f)


def solve_smtlib(filename: str, solver: SupportedSolvers) -> tuple[bool, int, list[str]]:
    file_dir = path.join(path.dirname(__file__), 'smt2')
    filepath = path.join(file_dir, filename)
    with timer() as elapsed:
        if solver.value == 'z3':
            res = subprocess.run(['z3', filepath], capture_output=True).stdout.decode('utf-8').strip()
        elif solver.value == 'yices':
            res = subprocess.run(['yices-smt2', filepath], capture_output=True).stdout.decode('utf-8').strip()
        else:
            res = subprocess.run(['cvc5', filepath, '--produce-models'], capture_output=True).stdout.decode(
                'utf-8').strip()
        solveTime = elapsed()
    resLines = res.split('\r\n')
    if resLines[0] == 'sat':
        res = True
    elif resLines[0] == 'unsat':
        res = False
    else:
        raise Exception(resLines[0])
    remove(f'smt2/{filename}')
    return res, solveTime, resLines[1:]


def extract_model_cvc(output: list[str]) -> dict:
    # RegEx generated by ChatGPT, 25/07/2024
    pattern = re.compile(r'\(define-fun (\|[\w|()_]+\|?|[\w|_]+) \(\) \(?_? ?(\w+) ?(\d*)\)? ?(true|false|#b[01]+|\w+)\)')
    model_dict = {}

    # Pattern Finding generated by ChatGPT, 25/07/2024
    for line in output:
        match = pattern.match(line)
        if match:
            variable_name = match.group(1)
            type_name = match.group(2)
            bit_width = match.group(3) if match.group(3) else ''  # Handle optional bit width
            value = match.group(4)
            model_dict[variable_name] = (type_name, bit_width, value)

    return model_dict


def extract_model_z3(output: list[str]) -> dict:
    # RegEx geenrated by ChatGPT, 10/08/2024
    pattern = re.compile(r'\(define-fun (\|[\w|()_]+\|?|[\w|_]+) \(\) \(?_? ?(\w+) ?(\d*)\)?\s+(\S+)\)')
    model_dict = {}

    # Pattern Finding generated by ChatGPT, 10/08/2024
    i = 0
    while i < len(output):
        match = re.match(pattern, "\n".join(output[i:i + 2]).strip())
        if match:
            variable_name = match.group(1)
            type_name = match.group(2)
            bit_width = match.group(3) if match.group(3) else ''  # Handle optional bit width
            value = match.group(4)
            model_dict[variable_name] = (type_name, bit_width, value)
            i += 2  # Skip the next line as it's already processed
        else:
            i += 1  # Move to the next line
    return model_dict


def _eval_model(model: list[str], vars, ctx, solver):
    if solver.value == 'cvc5':
        m = extract_model_cvc(model)
    if solver.value == 'z3':
        m = extract_model_z3(model)
    res = []

    for v in vars:
        # CVC (and maybe other solvers) remove the pipes if they're not needed. Therefore we check for pipes and remove
        # them if not needed, so we can correctly get the value from the output
        v = str(v)
        if '(' not in v and ')' not in v and '|' in v:
            # no brackets in v but pipes, means we have to remove the pipes
            v = v[1:-1]

        type, width, value = m[v]

        if type == 'BitVec':
            if value[0:2] == '#b':
                val = int(value.split('#b')[1], 2)
            elif value[0:2] == '#x':
                val = int(value.split('#x')[1], 16)
            w = int(width)
            res.append(BitVecVal(val, w, ctx))
        elif type == 'Operators':
            res.append(value)
        else:
            res.append(BoolVal(value == 'true', ctx))
    return res
