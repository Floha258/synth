import subprocess
import time
from enum import Enum
from contextlib import contextmanager
import re
from z3 import BitVecVal, BoolVal, Solver


# from oplib import Bv


@contextmanager
def timer():
    start = time.perf_counter_ns()
    yield lambda: time.perf_counter_ns() - start


class SupportedSolvers(Enum):
    CVC: str = 'cvc5'
    YICES: str = 'yices'


# TODO: Add set-logic command so yices recognizes BVs
def write_smt2(filename: str, solver, ctx=None, logic='QF_AUBV'):
    s = solver
    if not type(s) is Solver:
        s = Solver(ctx=ctx)  # TODO Might need to add ctx back to solver (Solver(ctx=ctx))
        s.add(solver)
    if filename:
        with open(filename, 'w') as f:
            print(f'(set-logic ALL)', file=f)
            print(s.to_smt2(), file=f)
            print('(get-model)', file=f)


def solve_smtlib(filename: str, solver: SupportedSolvers) -> tuple[bool, int, list[str]]:
    with timer() as elapsed:
        if solver.value == 'cvc5':
            res = subprocess.run([solver.value, filename, '--produce-models'], capture_output=True).stdout.decode(
                'utf-8').strip()
        else:
            res = subprocess.run(['yices-smt2.exe', filename], capture_output=True).stdout.decode('utf-8').strip()
        solveTime = elapsed()
    resLines = res.split('\r\n')
    if resLines[0] == 'sat':
        res = True
    elif resLines[0] == 'unsat':
        res = False
    else:
        raise Exception(resLines[0])
    return res, solveTime, resLines[1:]


def extract_model(output: list[str]) -> dict:
    # RegEx generated by ChatGPT, 25/07/2024
    pattern = re.compile(r'\(define-fun (\|[\w|()_]+\|?|[\w|_]+) \(\) \(?_? ?(\w+) ?(\d*)\)? ?(true|false|#b[01]+|\w+)\)')
    model_dict = {}

    # Pattern Finding generated by ChatGPT, 25/07/2024
    for line in output:
        match = pattern.match(line)
        if match:
            variable_name = match.group(1)
            type_name = match.group(2)
            bit_width = match.group(3) if match.group(3) else ''  # Handle optional bit width
            value = match.group(4)
            model_dict[variable_name] = (type_name, bit_width, value)

    return model_dict


def _eval_model(model: list[str], vars, ctx):
    m = extract_model(model)
    res = []

    for v in vars:
        # CVC (and maybe other solvers) remove the pipes if they're not needed. Therefore we check for pipes and remove
        # them if not needed, so we can correctly get the value from the output
        v = str(v)
        if '(' not in v and ')' not in v and '|' in v:
            # no brackets in v but pipes, means we have to remove the pipes
            v = v[1:-1]

        type, width, value = m[v]

        if type == 'BitVec':
            val = int(value.split('#b')[1], 2)
            w = int(width)
            res.append(BitVecVal(val, w, ctx))
        elif type == 'Operators':
            res.append(value)
        else:
            res.append(BoolVal(value == 'true', ctx))
    return res
