import subprocess
import time
from enum import Enum
from contextlib import contextmanager
import re
from z3 import BitVecVal, BoolVal
# from oplib import Bv


@contextmanager
def timer():
    start = time.perf_counter_ns()
    yield lambda: time.perf_counter_ns() - start


class SupportedSolvers(Enum):
    CVC: str = 'cvc5'
    YICES: str = 'yices'


def solve_smtlib(filename: str, solver: SupportedSolvers) -> tuple[bool, int, list[str]]:
    with timer() as elapsed:
        # TODO: Produce models is for cvc, yices might need a different command
        res = subprocess.run([solver.value, filename, '--produce-models'], capture_output=True).stdout.decode(
            'utf-8').strip()
        solveTime = elapsed()
    resLines = res.split('\r\n')
    return resLines[0] == 'sat', solveTime, resLines[1:]


def extract_model(output: list[str]) -> dict:
    # RegEx generated by ChatGPT, 25/07/2024
    pattern = re.compile(r'\(define-fun (\|[\w|()_]+\|?|[\w|_]+) \(\) \(?_? ?(\w+) ?(\d*)\)? ?(true|false|#b[01]+|\w+)\)')
    model_dict = {}

    # Pattern Finding generated by ChatGPT, 25/07/2024
    for line in output:
        match = pattern.match(line)
        if match:
            variable_name = match.group(1)
            type_name = match.group(2)
            bit_width = match.group(3) if match.group(3) else ''  # Handle optional bit width
            value = match.group(4)
            model_dict[variable_name] = (type_name, bit_width, value)

    return model_dict


def _eval_model(model: list[str], vars, ctx):
    m = extract_model(model)
    res = []

    for v in vars:
        # CVC (and maybe other solvers) remove the pipes if they're not needed. Therefore we check for pipes and remove
        # them if not needed, so we can correctly get the value from the output
        v = str(v)
        if '(' not in v and ')' not in v and '|' in v:
            # no brackets in v but pipes, means we have to remove the pipes
            v = v[1:-1]

        type, width, value = m[v]

        if type == 'BitVec':
            val = int(value.split('#b')[1], 2)
            w = int(width)
            res.append(BitVecVal(val, w, ctx))
        elif type == 'Operators':
            # TODO: import bv without circular import or shit
            # from oplib import Bv
            res.append(value)
            # res.append(True)
        else:
            res.append(BoolVal(value == 'true', ctx))
    return res
